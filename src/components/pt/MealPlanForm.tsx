import { useState, useEffect, useMemo, useCallback, useRef } from 'react';
import { useTranslation } from 'react-i18next';
import { useForm, Controller, useFieldArray, type Resolver } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import type { TFunction } from 'i18next';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { cn } from '@/utils/utils';
import type { MealPlanStatus, DayPlan, Meal, MealItem } from '@/types/api/MealPlan';

export interface MealPlanFormValues {
  customerId: string;
  customerGoalId: string;
  name: string;
  goal?: string;
  focus?: string;
  targetCalories?: number;
  notes?: string;
  status?: MealPlanStatus;
  days?: DayPlan[];
}

interface MealPlanFormProps {
  initialValues: MealPlanFormValues;
  loading?: boolean;
  onSubmit: (values: MealPlanFormValues) => void;
  isAiGenerated?: boolean; // Flag to disable ingredients editing when generated by AI
}

// Zod schema builder with i18n
const buildMealPlanSchema = (t: TFunction) => {
  const mealItemSchema = z.object({
    name: z
      .string()
      .trim()
      .min(1, t('meal_plan.validation.item_name_required'))
      .max(200, t('meal_plan.validation.item_name_max')),
    calories: z
      .number()
      .min(0, t('meal_plan.validation.item_calories_min'))
      .max(5000, t('meal_plan.validation.item_calories_max'))
      .optional()
      .or(z.undefined()),
    protein: z
      .number()
      .min(0, t('meal_plan.validation.item_protein_min'))
      .max(500, t('meal_plan.validation.item_protein_max'))
      .optional()
      .or(z.undefined()),
    carbs: z
      .number()
      .min(0, t('meal_plan.validation.item_carbs_min'))
      .max(1000, t('meal_plan.validation.item_carbs_max'))
      .optional()
      .or(z.undefined()),
    fat: z
      .number()
      .min(0, t('meal_plan.validation.item_fat_min'))
      .max(500, t('meal_plan.validation.item_fat_max'))
      .optional()
      .or(z.undefined()),
    ingredients: z
      .array(
        z.union([
          z.string().trim().max(200, t('meal_plan.validation.ingredient_max')),
          z.object({
            name: z.string().trim().max(200, t('meal_plan.validation.ingredient_max')),
            quantity_g: z.number().min(0).optional()
          })
        ])
      )
      .optional()
      .default([])
  });

  const mealSchema = z.object({
    mealType: z
      .string()
      .trim()
      .min(1, t('meal_plan.validation.meal_type_required'))
      .max(100, t('meal_plan.validation.meal_type_max')),
    items: z.array(mealItemSchema).min(1, t('meal_plan.validation.items_min')).default([]),
    totalCalories: z
      .number()
      .min(0, t('meal_plan.validation.meal_total_calories_min'))
      .max(5000, t('meal_plan.validation.meal_total_calories_max'))
      .optional()
      .or(z.undefined()),
    notes: z.string().trim().max(500, t('meal_plan.validation.meal_notes_max')).optional().or(z.undefined())
  });

  const dayPlanSchema = z.object({
    day: z.string().trim().min(1, t('meal_plan.validation.day_required')).max(100, t('meal_plan.validation.day_max')),
    meals: z
      .array(mealSchema)
      .min(3, t('meal_plan.validation.meals_min'))
      .default([])
      .superRefine((meals, ctx) => {
        const mealTypes = meals.map((meal) => meal.mealType?.trim().toLowerCase()).filter(Boolean);
        const duplicates = mealTypes.filter((type, index) => mealTypes.indexOf(type) !== index);

        if (duplicates.length > 0) {
          const uniqueDuplicates = new Set(duplicates);
          meals.forEach((meal, index) => {
            const mealTypeLower = meal.mealType?.trim().toLowerCase();
            if (uniqueDuplicates.has(mealTypeLower)) {
              ctx.addIssue({
                code: 'custom',
                message: t('meal_plan.validation.meal_type_duplicate'),
                path: [index, 'mealType']
              });
            }
          });
        }
      }),
    totalCalories: z
      .number()
      .min(0, t('meal_plan.validation.day_total_calories_min'))
      .max(10000, t('meal_plan.validation.day_total_calories_max'))
      .optional()
      .or(z.undefined())
  });

  return z.object({
    customerId: z.string().min(1),
    customerGoalId: z.string().min(1),
    name: z
      .string()
      .trim()
      .min(1, t('meal_plan.validation.name_required'))
      .max(200, t('meal_plan.validation.name_max')),
    goal: z.string().trim().max(500, t('meal_plan.validation.goal_max')).optional().or(z.undefined()),
    focus: z.string().trim().max(100, t('meal_plan.validation.focus_max')).optional().or(z.undefined()),
    targetCalories: z
      .number()
      .min(0, t('meal_plan.validation.target_calories_min'))
      .max(25000, t('meal_plan.validation.target_calories_max'))
      .optional()
      .or(z.undefined()),
    notes: z.string().trim().max(2000, t('meal_plan.validation.notes_max')).optional().or(z.undefined()),
    status: z.enum(['SUGGESTED', 'EDITED', 'FINAL', 'ARCHIVED', 'DELETED']).optional(),
    days: z
      .array(dayPlanSchema)
      .min(1, t('meal_plan.validation.days_min'))
      .max(14, t('meal_plan.validation.days_max'))
      .optional()
      .default([])
  });
};

export const MealPlanForm = ({ initialValues, loading, onSubmit, isAiGenerated = false }: MealPlanFormProps) => {
  const { t } = useTranslation();
  const schema = useMemo(() => buildMealPlanSchema(t), [t]);

  // Create a Set of AI-generated item IDs from initialValues for quick lookup
  const aiGeneratedItemIds = useMemo(() => {
    if (!isAiGenerated) return new Set<string>();
    const ids = new Set<string>();
    (initialValues.days || []).forEach((day) => {
      (day.meals || []).forEach((meal) => {
        (meal.items || []).forEach((item) => {
          const aiId = (item as { _aiId?: string })?._aiId;
          if (aiId) {
            ids.add(aiId);
          }
        });
      });
    });
    return ids;
  }, [isAiGenerated, initialValues.days]);

  // Memoize computation functions to prevent recreation on every render
  const computeMealWithTotal = useCallback((meal: Meal) => {
    const mealTotal = (meal.items || []).reduce((sum, item) => sum + (item.calories || 0), 0);
    return { ...meal, totalCalories: mealTotal > 0 ? mealTotal : undefined };
  }, []);

  const computeDayWithTotals = useCallback(
    (day: DayPlan) => {
      const meals = (day.meals || []).map(computeMealWithTotal);
      const dayTotal = meals.reduce((sum, m) => sum + (m.totalCalories || 0), 0);
      return { ...day, meals, totalCalories: dayTotal > 0 ? dayTotal : undefined };
    },
    [computeMealWithTotal]
  );

  const {
    control,
    handleSubmit,
    watch,
    getValues,
    setValue,
    clearErrors,
    trigger,
    reset,
    formState: { errors }
  } = useForm<MealPlanFormValues>({
    resolver: zodResolver(schema) as Resolver<MealPlanFormValues>,
    defaultValues: {
      customerId: initialValues.customerId,
      customerGoalId: initialValues.customerGoalId,
      name: initialValues.name || '',
      goal: initialValues.goal,
      focus: initialValues.focus,
      targetCalories: initialValues.targetCalories,
      notes: initialValues.notes,
      status: initialValues.status || 'SUGGESTED',
      days: initialValues.days || []
    },
    mode: 'onBlur', // Changed to onBlur to reduce re-renders while typing
    reValidateMode: 'onBlur', // Only validate on blur, not on every keystroke
    shouldUnregister: false, // Keep form state to prevent re-initialization
    shouldFocusError: false // Don't auto-focus on error to prevent scroll jumps
  });

  const {
    fields: dayFields,
    append: appendDay,
    remove: removeDay
  } = useFieldArray({
    control,
    name: 'days'
  });

  // Use getValues() to read current values without subscribing to changes
  const getDaysValue = useCallback(() => {
    return watch('days') || [];
  }, [watch]);

  // Cache days for rendering - only update when structure changes, not on every keystroke
  const [cachedDays, setCachedDays] = useState<DayPlan[]>(initialValues.days || []);

  // Update cached days only when structure changes (add/remove day/meal/item), not on input change
  useEffect(() => {
    const currentDays = getDaysValue();
    // Only update if structure changed (length or items count)
    const structureChanged =
      cachedDays.length !== currentDays.length ||
      cachedDays.some(
        (day, idx) =>
          (day?.meals?.length || 0) !== (currentDays[idx]?.meals?.length || 0) ||
          day?.meals?.some(
            (meal, mealIdx) => (meal?.items?.length || 0) !== (currentDays[idx]?.meals?.[mealIdx]?.items?.length || 0)
          )
      );

    if (structureChanged) {
      setCachedDays(currentDays);
    }
  }, [getDaysValue, cachedDays.length]); // Only depend on length, not content

  // Use cachedDays for rendering to avoid re-renders on every keystroke
  const watchedDays = cachedDays;

  // Memoize days with totals to avoid recalculating on every render
  const daysWithTotals = useMemo(() => {
    return watchedDays.map(computeDayWithTotals);
  }, [watchedDays, computeDayWithTotals]);

  // Memoize meals with totals for each day to avoid recalculating on every render
  const mealsWithTotalsByDay = useMemo(() => {
    const result: Record<number, ReturnType<typeof computeMealWithTotal>[]> = {};
    watchedDays.forEach((day, dayIdx) => {
      if (day?.meals) {
        result[dayIdx] = day.meals.map(computeMealWithTotal);
      }
    });
    return result;
  }, [watchedDays, computeMealWithTotal]);

  const getArrayErrorMessage = (arrError: unknown): string | undefined => {
    if (!arrError || typeof arrError !== 'object') return undefined;
    const anyErr = arrError as { message?: unknown; _errors?: unknown; root?: { message?: unknown } };
    if (typeof anyErr.message === 'string') return anyErr.message;
    if (anyErr.root && typeof anyErr.root.message === 'string') return anyErr.root.message;
    if (Array.isArray(anyErr._errors) && typeof anyErr._errors[0] === 'string') return anyErr._errors[0] as string;
    return undefined;
  };

  // Function to recalculate and update all totals (meal, day, target)
  const recalculateTotals = useCallback(() => {
    // Use getValues() directly to get the absolute latest data from form state
    const formValues = getValues();
    const currentDays = formValues.days || [];

    if (!currentDays || currentDays.length === 0) {
      return;
    }

    // Create a deep copy without totalCalories to force recalculation from items
    const daysWithoutTotals = currentDays.map((day) => ({
      ...day,
      totalCalories: undefined,
      meals: day.meals?.map((meal) => ({
        ...meal,
        totalCalories: undefined
      }))
    }));

    const daysWithTotals = daysWithoutTotals.map(computeDayWithTotals);

    // Clear day.meals min errors when satisfied
    currentDays.forEach((d, idx) => {
      if ((d.meals?.length || 0) >= 3) {
        clearErrors(`days.${idx}.meals`);
      }
    });

    // Batch all setValue calls to minimize re-renders
    const updates: Array<{ path: string; value: unknown }> = [];

    // Update days with calculated totals
    daysWithTotals.forEach((day, dayIdx) => {
      const currentDay = currentDays[dayIdx];
      const currentDayTotal = currentDay?.totalCalories ?? undefined;
      const newDayTotal = day.totalCalories ?? undefined;

      // Update day totalCalories
      if (currentDayTotal !== newDayTotal) {
        updates.push({ path: `days.${dayIdx}.totalCalories`, value: newDayTotal });
      }

      // Update meal totalCalories
      day.meals?.forEach((meal, mealIdx) => {
        const currentMeal = currentDay?.meals?.[mealIdx];
        const currentMealTotal = currentMeal?.totalCalories ?? undefined;
        const newMealTotal = meal.totalCalories ?? undefined;

        if (currentMealTotal !== newMealTotal) {
          updates.push({
            path: `days.${dayIdx}.meals.${mealIdx}.totalCalories`,
            value: newMealTotal
          });
        }
      });
    });

    // Calculate target calories (sum of all days)
    const countedDays = daysWithTotals.filter((d) => typeof d.totalCalories === 'number' && d.totalCalories > 0);
    const targetCalories =
      countedDays.length > 0 ? countedDays.reduce((sum, d) => sum + (d.totalCalories || 0), 0) : undefined;

    const currentTarget = watch('targetCalories') ?? undefined;
    if (targetCalories !== currentTarget) {
      updates.push({ path: 'targetCalories', value: targetCalories });
    }

    // Apply all updates at once to minimize re-renders
    if (updates.length > 0) {
      updates.forEach(({ path, value }) => {
        // Use type assertion for dynamic paths
        (
          setValue as (
            name: string,
            value: unknown,
            options?: { shouldValidate?: boolean; shouldDirty?: boolean }
          ) => void
        )(path, value, { shouldValidate: false, shouldDirty: false });
      });
    }

    // Update cached days after totals calculation to reflect new totals in UI
    setCachedDays(daysWithTotals);
  }, [getValues, setValue, clearErrors, computeDayWithTotals, watch]);

  // Recalculate totals when data changes (debounced to reduce lag while typing)
  const watchedDaysForTotals = watch('days') || [];

  useEffect(() => {
    // Debounce calculation with longer delay to reduce lag while typing
    const timeoutId = setTimeout(() => {
      recalculateTotals();
    }, 800); // Increased to 800ms debounce for better performance

    return () => {
      clearTimeout(timeoutId);
    };
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [watchedDaysForTotals]); // Trigger when days structure or values change

  const addDay = () => {
    const currentDays = watch('days') || [];
    const dayNumber = currentDays.length + 1;
    const dayPrefix = t('meal_plan.form.day_prefix');
    const newDay: DayPlan = {
      day: `${dayPrefix} ${dayNumber}`,
      meals: []
    };
    appendDay(newDay);
  };

  const addMeal = (dayIdx: number) => {
    const currentDays = getDaysValue();
    const day = currentDays[dayIdx];
    const meals = day?.meals || [];
    const newMeal: Meal = { mealType: '', items: [] };
    const nextMeals = [...meals, newMeal];
    setValue(`days.${dayIdx}.meals`, nextMeals, { shouldValidate: true });
    if (nextMeals.length >= 3) {
      clearErrors(`days.${dayIdx}.meals`);
    } else {
      void trigger(`days.${dayIdx}.meals`);
    }
    // Update cached days after adding meal
    setTimeout(() => setCachedDays(getDaysValue()), 0);
  };

  const removeMeal = (dayIdx: number, mealIdx: number) => {
    const currentDays = getDaysValue();
    const day = currentDays[dayIdx];
    const meals = day?.meals || [];
    meals.splice(mealIdx, 1);
    setValue(`days.${dayIdx}.meals`, meals, { shouldValidate: true });
    void trigger(`days.${dayIdx}.meals`);
    if (meals.length >= 3) {
      clearErrors(`days.${dayIdx}.meals`);
    }
    // Update cached days after removing meal
    setTimeout(() => setCachedDays(getDaysValue()), 0);
  };

  const addItem = (dayIdx: number, mealIdx: number) => {
    const currentDays = getDaysValue();
    const day = currentDays[dayIdx];
    const meal = day?.meals?.[mealIdx];
    const items = meal?.items || [];
    // Create a completely new item with all fields explicitly set to undefined/empty
    const newItem: MealItem & { _itemId?: string } = {
      name: '',
      calories: undefined,
      protein: undefined,
      carbs: undefined,
      fat: undefined,
      ingredients: [],
      _itemId: `item-${Date.now()}-${Math.random()}`
    };
    setValue(`days.${dayIdx}.meals.${mealIdx}.items`, [...items, newItem], {
      shouldValidate: true,
      shouldDirty: true
    });
    // Update cached days after adding item
    setTimeout(() => setCachedDays(getDaysValue()), 0);
  };

  const removeItem = (dayIdx: number, mealIdx: number, itemIdx: number) => {
    const currentDays = getDaysValue();
    const day = currentDays[dayIdx];
    const meal = day?.meals?.[mealIdx];
    const items = meal?.items || [];

    // Clear localInputValuesRef for the removed item BEFORE removing it
    const fieldsToClear = ['name', 'cal', 'protein', 'carbs', 'fat'];
    fieldsToClear.forEach((field) => {
      const key = `${field}-${dayIdx}-${mealIdx}-${itemIdx}`;
      if (localInputValuesRef.current[key] !== undefined) {
        delete localInputValuesRef.current[key];
      }
    });
    // Clear ingredients ref
    const ingredientsKey = `${dayIdx}-${mealIdx}-${itemIdx}`;
    if (localInputValuesRef.current[`ingredients-${ingredientsKey}`] !== undefined) {
      delete localInputValuesRef.current[`ingredients-${ingredientsKey}`];
    }
    if (ingredientsRawText[ingredientsKey] !== undefined) {
      setIngredientsRawText((prev) => {
        const updated = { ...prev };
        delete updated[ingredientsKey];
        return updated;
      });
    }

    // Create new array without the removed item
    const timestamp = Date.now();
    const newItems = items
      .filter((_, idx) => idx !== itemIdx)
      .map((item, newIdx) => {
        // Explicitly create a new object with only the fields we want
        const cleanItem: MealItem = {
          name: item.name ?? '',
          calories: item.calories ?? undefined,
          protein: item.protein ?? undefined,
          carbs: item.carbs ?? undefined,
          fat: item.fat ?? undefined,
          ingredients: item.ingredients ?? []
        };
        // Preserve _aiId if it exists (for AI-generated items)
        if ((item as { _aiId?: string })?._aiId) {
          (cleanItem as { _aiId?: string })._aiId = (item as { _aiId?: string })?._aiId;
        }
        // Generate NEW _itemId for all items to force React remount
        (cleanItem as { _itemId?: string })._itemId =
          `item-${dayIdx}-${mealIdx}-${newIdx}-${timestamp}-${Math.random()}`;
        return cleanItem;
      });

    // Clear errors for removed item and all items after it (because indices shift)
    clearErrors(`days.${dayIdx}.meals.${mealIdx}.items.${itemIdx}`);
    // Clear errors for all items after the removed one (indices have shifted)
    for (let i = itemIdx; i < items.length; i++) {
      clearErrors(`days.${dayIdx}.meals.${mealIdx}.items.${i}`);
    }

    // Get current form values to update only the items array
    const currentFormValues = getValues();
    const updatedDays = [...(currentFormValues.days || [])];
    if (updatedDays[dayIdx]?.meals?.[mealIdx]) {
      updatedDays[dayIdx].meals[mealIdx].items = newItems;
    }

    // Use reset to completely replace the form state, which forces React Hook Form
    reset(
      {
        ...currentFormValues,
        days: updatedDays
      },
      {
        keepDefaultValues: false,
        keepValues: false
      }
    );

    // Verify the update worked
    setTimeout(() => {
      const verifyDays = getDaysValue();
      setCachedDays(verifyDays);
    }, 0);
  };

  const [itemsModal, setItemsModal] = useState<{ dayIdx: number; mealIdx: number } | null>(null);
  const [ingredientsRawText, setIngredientsRawText] = useState<Record<string, string>>({});

  // Local state for text inputs to prevent lag while typing
  const [localInputValues, setLocalInputValues] = useState<Record<string, string>>({});

  // Use ref to cache local values without triggering re-renders
  const localInputValuesRef = useRef<Record<string, string>>({});

  const onFormSubmit = (data: MealPlanFormValues) => {
    // Remove _aiId and _itemId from items before submitting (they're only for tracking in the form)
    const processedData: MealPlanFormValues = {
      ...data,
      days: (data.days || []).map((day) => {
        const dayWithTotals = computeDayWithTotals(day);
        return {
          ...dayWithTotals,
          meals: (dayWithTotals.meals || []).map((meal) => ({
            ...meal,
            items: (meal.items || []).map((item) => {
              // eslint-disable-next-line @typescript-eslint/no-unused-vars
              const { _aiId, _itemId, ...itemWithoutIds } = item as MealItem & { _aiId?: string; _itemId?: string };
              return itemWithoutIds;
            })
          }))
        };
      })
    };
    onSubmit(processedData);
  };

  return (
    <form className="space-y-4 px-1" onSubmit={handleSubmit(onFormSubmit)}>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="name">
            {t('meal_plan.form.name')} <span className="text-red-500">*</span>
          </Label>
          <Controller
            name="name"
            control={control}
            render={({ field }) => (
              <div>
                <Input
                  id="name"
                  {...field}
                  value={field.value || ''}
                  placeholder={t('meal_plan.form.name_placeholder')}
                  className={cn(errors.name && 'border-red-500')}
                />
                <div className="min-h-[20px]">
                  {errors.name && <p className="text-sm text-red-600 mt-1">{errors.name.message}</p>}
                </div>
              </div>
            )}
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="status">{t('meal_plan.form.status')}</Label>
          <Controller
            name="status"
            control={control}
            render={({ field }) => (
              <div>
                <Select value={field.value || 'SUGGESTED'} onValueChange={field.onChange}>
                  <SelectTrigger id="status" className={cn('w-full', errors.status && 'border-red-500')}>
                    <SelectValue placeholder={t('meal_plan.form.status_placeholder')} />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="SUGGESTED">{t('meal_plan.status.SUGGESTED')}</SelectItem>
                    <SelectItem value="FINAL">{t('meal_plan.status.FINAL')}</SelectItem>
                    <SelectItem value="EDITED">{t('meal_plan.status.EDITED')}</SelectItem>
                    <SelectItem value="ARCHIVED">{t('meal_plan.status.ARCHIVED')}</SelectItem>
                    <SelectItem value="DELETED">{t('meal_plan.status.DELETED')}</SelectItem>
                  </SelectContent>
                </Select>
                <div className="min-h-[20px]">
                  {errors.status && <p className="text-sm text-red-600 mt-1">{errors.status.message}</p>}
                </div>
              </div>
            )}
          />
        </div>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div className="space-y-2">
          <Label htmlFor="focus">{t('meal_plan.form.focus')}</Label>
          <Controller
            name="focus"
            control={control}
            render={({ field }) => (
              <div>
                <Input
                  id="focus"
                  {...field}
                  value={field.value || ''}
                  onChange={(e) => field.onChange(e.target.value)}
                  placeholder={t('meal_plan.form.focus_placeholder')}
                  className={cn(errors.focus && 'border-red-500')}
                />
                <div className="min-h-[20px]">
                  {errors.focus && <p className="text-sm text-red-600 mt-1">{errors.focus.message}</p>}
                </div>
              </div>
            )}
          />
        </div>
        <div className="space-y-2">
          <Label htmlFor="targetCalories">{t('meal_plan.form.target_calories')}</Label>
          <Controller
            name="targetCalories"
            control={control}
            render={({ field }) => {
              // Use memoized daysWithTotals instead of recalculating
              const countedDays = daysWithTotals.filter(
                (d) => typeof d.totalCalories === 'number' && d.totalCalories > 0
              );
              const calculatedTarget =
                countedDays.length > 0 ? countedDays.reduce((sum, d) => sum + (d.totalCalories || 0), 0) : undefined;

              return (
                <div>
                  <Input
                    id="targetCalories"
                    type="number"
                    {...field}
                    value={calculatedTarget ?? ''}
                    disabled
                    placeholder={t('meal_plan.form.target_calories_placeholder')}
                    className={cn(errors.targetCalories && 'border-red-500')}
                  />
                  <div className="min-h-[20px]">
                    {errors.targetCalories && (
                      <p className="text-sm text-red-600 mt-1">{errors.targetCalories.message}</p>
                    )}
                  </div>
                </div>
              );
            }}
          />
        </div>
      </div>

      <div className="space-y-2">
        <Label htmlFor="notes">{t('meal_plan.form.notes')}</Label>
        <Controller
          name="notes"
          control={control}
          render={({ field }) => (
            <div>
              <Textarea
                id="notes"
                {...field}
                value={field.value || ''}
                onChange={(e) => field.onChange(e.target.value)}
                placeholder={t('meal_plan.form.notes_placeholder')}
                className={cn(errors.notes && 'border-red-500')}
              />
              <div className="min-h-[20px]">
                {errors.notes && <p className="text-sm text-red-600 mt-1">{errors.notes.message}</p>}
              </div>
            </div>
          )}
        />
      </div>

      <div className="flex items-center justify-between">
        <CardTitle className="text-lg">{t('meal_plan.form.days')}</CardTitle>
        <Button type="button" variant="outline" onClick={addDay}>
          {t('meal_plan.form.add_day')}
        </Button>
      </div>
      <div className="min-h-[20px]">
        {errors.days && typeof errors.days === 'object' && 'message' in errors.days && (
          <p className="text-sm text-red-600 mt-1">{errors.days.message as string}</p>
        )}
      </div>

      <div className="space-y-3">
        {dayFields.map((dayField, dayIdx) => {
          const day = watchedDays[dayIdx];
          const dayErrors = errors.days?.[dayIdx];
          const mealsArrayMessage = getArrayErrorMessage(dayErrors?.meals);
          const dayTotals = daysWithTotals[dayIdx] || { totalCalories: undefined };

          return (
            <Card key={dayField.id}>
              <CardHeader className="flex flex-row items-start justify-between">
                <div className="flex items-start gap-3">
                  <div className="space-y-1">
                    <Controller
                      name={`days.${dayIdx}.day`}
                      control={control}
                      render={({ field }) => {
                        const fieldKey = `day-${dayIdx}`;
                        const localValue = localInputValues[fieldKey] ?? field.value ?? '';

                        return (
                          <div>
                            <Input
                              className={cn('w-40', dayErrors?.day && 'border-red-500')}
                              value={localValue}
                              onChange={(e) => {
                                setLocalInputValues((prev) => ({
                                  ...prev,
                                  [fieldKey]: e.target.value
                                }));
                              }}
                              onBlur={(e) => {
                                field.onChange(e.target.value);
                                setLocalInputValues((prev) => {
                                  const updated = { ...prev };
                                  delete updated[fieldKey];
                                  return updated;
                                });
                              }}
                              placeholder={t('meal_plan.form.day_label_placeholder')}
                            />
                            <div className="min-h-[16px]">
                              {dayErrors?.day && <p className="text-xs text-red-600 mt-1">{dayErrors.day.message}</p>}
                            </div>
                          </div>
                        );
                      }}
                    />
                  </div>
                  <div className="space-y-1">
                    <div className="relative w-32">
                      <Input
                        className="w-full pr-12"
                        type="text"
                        value={dayTotals.totalCalories ? `${dayTotals.totalCalories} cal` : ''}
                        disabled
                      />
                    </div>
                    <div className="min-h-[16px]"></div>
                  </div>
                </div>
                <div className="space-y-1">
                  <div className="flex gap-2 h-10 items-center">
                    <Button type="button" variant="outline" size="sm" onClick={() => addMeal(dayIdx)}>
                      {t('meal_plan.table.add_meal')}
                    </Button>
                    <Button type="button" variant="destructive" size="sm" onClick={() => removeDay(dayIdx)}>
                      {t('common.remove')}
                    </Button>
                  </div>
                  <div className="min-h-[16px]"></div>
                </div>
              </CardHeader>
              <CardContent className="space-y-3">
                <div className="overflow-x-auto">
                  <table className="w-full text-sm border">
                    <thead className="bg-muted/50">
                      <tr>
                        <th className="p-2 text-left">{t('meal_plan.table.meal')}</th>
                        <th className="p-2 text-left w-24">{t('meal_plan.table.total_cal')}</th>
                        <th className="p-2 text-left w-1/3">{t('meal_plan.table.notes')}</th>
                        <th className="p-2 text-left w-40">{t('meal_plan.table.actions')}</th>
                      </tr>
                    </thead>
                    <tbody>
                      {(day?.meals || []).map((_meal, mealIdx) => {
                        const mealErrors = dayErrors?.meals?.[mealIdx];
                        const mealTotals = mealsWithTotalsByDay[dayIdx]?.[mealIdx] || { totalCalories: undefined };

                        return (
                          <tr key={mealIdx} className="border-t">
                            <td className="p-2">
                              <div className="space-y-1">
                                <Controller
                                  name={`days.${dayIdx}.meals.${mealIdx}.mealType`}
                                  control={control}
                                  render={({ field }) => (
                                    <div>
                                      <Select value={field.value || ''} onValueChange={field.onChange}>
                                        <SelectTrigger
                                          className={cn('w-full', mealErrors?.mealType && 'border-red-500')}
                                        >
                                          <SelectValue placeholder={t('meal_plan.table.meal_placeholder')} />
                                        </SelectTrigger>
                                        <SelectContent>
                                          <SelectItem value="breakfast">
                                            {t('meal_plan.table.meal_types.breakfast')}
                                          </SelectItem>
                                          <SelectItem value="lunch">{t('meal_plan.table.meal_types.lunch')}</SelectItem>
                                          <SelectItem value="dinner">
                                            {t('meal_plan.table.meal_types.dinner')}
                                          </SelectItem>
                                          <SelectItem value="snack">{t('meal_plan.table.meal_types.snack')}</SelectItem>
                                          <SelectItem value="pre_workout">
                                            {t('meal_plan.table.meal_types.pre_workout')}
                                          </SelectItem>
                                          <SelectItem value="post_workout">
                                            {t('meal_plan.table.meal_types.post_workout')}
                                          </SelectItem>
                                          <SelectItem value="late_night">
                                            {t('meal_plan.table.meal_types.late_night')}
                                          </SelectItem>
                                          <SelectItem value="other">{t('meal_plan.table.meal_types.other')}</SelectItem>
                                        </SelectContent>
                                      </Select>
                                      <div className="min-h-[16px]">
                                        {mealErrors?.mealType && (
                                          <p className="text-xs text-red-600 mt-1">{mealErrors.mealType.message}</p>
                                        )}
                                      </div>
                                    </div>
                                  )}
                                />
                              </div>
                            </td>
                            <td className="p-2 align-middle w-24">
                              <div className="min-h-[54px] flex items-start">
                                <Input type="number" value={mealTotals.totalCalories ?? ''} disabled className="w-24" />
                              </div>
                            </td>
                            <td className="p-2 align-middle w-1/3">
                              <div className="space-y-1">
                                <Controller
                                  name={`days.${dayIdx}.meals.${mealIdx}.notes`}
                                  control={control}
                                  render={({ field }) => {
                                    const fieldKey = `meal-notes-${dayIdx}-${mealIdx}`;
                                    const defaultValue = field.value ?? '';

                                    return (
                                      <>
                                        <Textarea
                                          key={`notes-${dayIdx}-${mealIdx}-${defaultValue}`}
                                          defaultValue={defaultValue}
                                          onChange={(e) => {
                                            // Only update ref, no state update = no re-render
                                            localInputValuesRef.current[fieldKey] = e.target.value;
                                          }}
                                          onBlur={(e) => {
                                            field.onBlur();
                                            field.onChange(e.target.value);
                                            // Clear from ref after sync
                                            delete localInputValuesRef.current[fieldKey];
                                          }}
                                          placeholder={t('meal_plan.table.notes_placeholder')}
                                          className={cn(
                                            'min-h-[38px] h-[38px] resize-none',
                                            mealErrors?.notes && 'border-red-500'
                                          )}
                                        />
                                        <div className="min-h-[16px]">
                                          {mealErrors?.notes && (
                                            <p className="text-xs text-red-600 mt-1">{mealErrors.notes.message}</p>
                                          )}
                                        </div>
                                      </>
                                    );
                                  }}
                                />
                              </div>
                            </td>
                            <td className="p-2 align-middle">
                              <div className="min-h-[54px] flex items-center">
                                <div className="flex flex-wrap items-center gap-2">
                                  <Button
                                    type="button"
                                    variant="outline"
                                    size="sm"
                                    onClick={() => {
                                      // Clear all ref values for this meal BEFORE opening modal
                                      const keysToClear = Object.keys(localInputValuesRef.current).filter((key) =>
                                        key.includes(`-${dayIdx}-${mealIdx}-`)
                                      );
                                      keysToClear.forEach((key) => {
                                        delete localInputValuesRef.current[key];
                                      });
                                      // Also clear ingredientsRawText
                                      const ingredientsKeysToClear = Object.keys(ingredientsRawText).filter((key) =>
                                        key.startsWith(`${dayIdx}-${mealIdx}-`)
                                      );
                                      setIngredientsRawText((prev) => {
                                        const updated = { ...prev };
                                        ingredientsKeysToClear.forEach((key) => {
                                          delete updated[key];
                                        });
                                        return updated;
                                      });
                                      setItemsModal({ dayIdx, mealIdx });
                                    }}
                                  >
                                    {t('meal_plan.table.items')}
                                  </Button>
                                  <Button
                                    type="button"
                                    variant="destructive"
                                    size="sm"
                                    onClick={() => removeMeal(dayIdx, mealIdx)}
                                  >
                                    {t('common.remove')}
                                  </Button>
                                </div>
                              </div>
                              <div className="min-h-[16px]">
                                {mealErrors?.items &&
                                  typeof mealErrors.items === 'object' &&
                                  'message' in mealErrors.items && (
                                    <p className="text-xs leading-4 text-red-600">
                                      {mealErrors.items.message as string}
                                    </p>
                                  )}
                              </div>
                            </td>
                          </tr>
                        );
                      })}
                      {(day?.meals || []).length === 0 && (
                        <tr>
                          <td className="p-3 text-center text-gray-500" colSpan={4}>
                            {t('meal_plan.table.no_meals')}
                          </td>
                        </tr>
                      )}
                    </tbody>
                  </table>
                </div>
                {mealsArrayMessage && (
                  <div className="min-h-[20px]">
                    <p className="text-sm text-red-600">{mealsArrayMessage}</p>
                  </div>
                )}
              </CardContent>
            </Card>
          );
        })}
      </div>

      <Dialog
        open={!!itemsModal}
        onOpenChange={(open) => {
          if (open) {
            // itemsModal will be set by the button click, but we need to get it from the state
            // Actually, when open is true, itemsModal should already be set
          } else if (!open && itemsModal) {
            // Force sync all pending form values before closing
            if (itemsModal) {
              // Use getValues() to get latest form state
              const formValues = getValues();
              const currentDays = formValues.days || [];
              const day = currentDays[itemsModal.dayIdx];
              const meal = day?.meals?.[itemsModal.mealIdx];
              const items = meal?.items || [];

              // Sync all local input values to form state
              items.forEach((_item: MealItem, itemIdx: number) => {
                // Sync name
                const nameKey = `name-${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                if (localInputValuesRef.current[nameKey] !== undefined) {
                  const nameValue = localInputValuesRef.current[nameKey];
                  setValue(`days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.name`, nameValue, {
                    shouldValidate: false,
                    shouldDirty: false
                  });
                }

                // Sync calories
                const calKey = `cal-${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                if (localInputValuesRef.current[calKey] !== undefined) {
                  const calValue = localInputValuesRef.current[calKey];
                  const numValue = calValue && calValue.trim() !== '' ? Number(calValue) : undefined;
                  setValue(
                    `days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.calories`,
                    numValue,
                    {
                      shouldValidate: false,
                      shouldDirty: false
                    }
                  );
                }

                // Sync protein
                const proteinKey = `protein-${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                if (localInputValuesRef.current[proteinKey] !== undefined) {
                  const proteinValue = localInputValuesRef.current[proteinKey];
                  const numValue = proteinValue && proteinValue.trim() !== '' ? Number(proteinValue) : undefined;
                  setValue(`days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.protein`, numValue, {
                    shouldValidate: false,
                    shouldDirty: false
                  });
                }

                // Sync carbs
                const carbsKey = `carbs-${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                if (localInputValuesRef.current[carbsKey] !== undefined) {
                  const carbsValue = localInputValuesRef.current[carbsKey];
                  const numValue = carbsValue && carbsValue.trim() !== '' ? Number(carbsValue) : undefined;
                  setValue(`days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.carbs`, numValue, {
                    shouldValidate: false,
                    shouldDirty: false
                  });
                }

                // Sync fat
                const fatKey = `fat-${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                if (localInputValuesRef.current[fatKey] !== undefined) {
                  const fatValue = localInputValuesRef.current[fatKey];
                  const numValue = fatValue && fatValue.trim() !== '' ? Number(fatValue) : undefined;
                  setValue(`days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.fat`, numValue, {
                    shouldValidate: false,
                    shouldDirty: false
                  });
                }

                // Sync ingredients
                const ingredientsKey = `${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                if (ingredientsRawText[ingredientsKey] !== undefined) {
                  const ingredientsValue = ingredientsRawText[ingredientsKey];
                  const newValue = ingredientsValue
                    ? ingredientsValue
                        .split('\n')
                        .map((s) => s.trim())
                        .filter(Boolean)
                    : [];
                  setValue(
                    `days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.ingredients`,
                    newValue,
                    {
                      shouldValidate: false,
                      shouldDirty: false
                    }
                  );
                }
              });
            }

            setItemsModal(null);
            // Reset raw text when modal closes
            setIngredientsRawText({});
            // Clear local input values ref
            if (itemsModal) {
              Object.keys(localInputValuesRef.current).forEach((key) => {
                if (key.includes(`-${itemsModal.dayIdx}-${itemsModal.mealIdx}-`)) {
                  delete localInputValuesRef.current[key];
                }
              });
            }

            setTimeout(() => {
              recalculateTotals();
            }, 200);
          }
        }}
      >
        <DialogContent className="max-w-5xl max-h-[80vh] flex flex-col">
          <DialogHeader className="flex-shrink-0">
            <DialogTitle>{t('meal_plan.items_dialog.title')}</DialogTitle>
          </DialogHeader>
          {itemsModal && (
            <div className="flex flex-col space-y-3 flex-1 min-h-0">
              <div className="flex gap-2 flex-shrink-0">
                <Button
                  type="button"
                  variant="outline"
                  size="sm"
                  onClick={() => addItem(itemsModal.dayIdx, itemsModal.mealIdx)}
                >
                  {t('meal_plan.items_dialog.add_item')}
                </Button>
              </div>
              <div className="space-y-2 overflow-y-auto flex-1 min-h-0 pr-2">
                {(() => {
                  // Get current items directly from form without watching
                  const currentDays = getDaysValue();
                  const items = currentDays[itemsModal.dayIdx]?.meals?.[itemsModal.mealIdx]?.items || [];

                  return items.map((_item, itemIdx) => {
                    const itemErrors = errors.days?.[itemsModal.dayIdx]?.meals?.[itemsModal.mealIdx]?.items?.[itemIdx];
                    const currentItem = items[itemIdx];

                    // Use _itemId as key if available, otherwise fallback to index
                    const itemKey = (currentItem as { _itemId?: string })?._itemId || `item-${itemIdx}`;

                    // Check if this item is from AI by checking if its _aiId exists in the Set
                    const currentAiId = (currentItem as { _aiId?: string })?._aiId;
                    const isItemFromAi =
                      isAiGenerated && currentAiId !== undefined && aiGeneratedItemIds.has(currentAiId);

                    // Helper function to render number input field
                    const renderNumberInput = (
                      fieldName: 'calories' | 'protein' | 'carbs' | 'fat',
                      labelKey: string,
                      fieldPrefix: string
                    ) => {
                      const fieldKey = `${fieldPrefix}-${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                      const errorField = itemErrors?.[fieldName];

                      return (
                        <div className="space-y-1">
                          <Label>{t(labelKey)}</Label>
                          <Controller
                            name={`days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.${fieldName}`}
                            control={control}
                            render={({ field }) => {
                              const defaultValue =
                                field.value !== undefined && field.value !== null ? String(field.value) : '';

                              return (
                                <div>
                                  <Input
                                    key={`${fieldPrefix}-${itemKey}-${defaultValue}`}
                                    type="number"
                                    defaultValue={defaultValue}
                                    onChange={(e) => {
                                      localInputValuesRef.current[fieldKey] = e.target.value;
                                    }}
                                    onBlur={async (e) => {
                                      const numValue =
                                        e.target.value && e.target.value.trim() !== ''
                                          ? Number(e.target.value)
                                          : undefined;
                                      field.onChange(numValue);
                                      field.onBlur(); // Trigger validation
                                      // Manually trigger validation to ensure it runs
                                      await trigger(
                                        `days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.${fieldName}`
                                      );
                                      delete localInputValuesRef.current[fieldKey];
                                    }}
                                    disabled={isItemFromAi}
                                    className={cn(
                                      errorField && 'border-red-500',
                                      isItemFromAi && 'bg-gray-100 cursor-not-allowed'
                                    )}
                                  />
                                  <div className="min-h-[16px]">
                                    {errorField && <p className="text-xs text-red-600 mt-1">{errorField.message}</p>}
                                  </div>
                                </div>
                              );
                            }}
                          />
                        </div>
                      );
                    };

                    return (
                      <div key={itemKey} className="border rounded-md p-3">
                        <div className="grid grid-cols-1 md:grid-cols-9 gap-2 items-start">
                          <div className="md:col-span-2 space-y-1">
                            <Label>{t('meal_plan.items_dialog.name_label')}</Label>
                            <Controller
                              name={`days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.name`}
                              control={control}
                              render={({ field }) => {
                                const fieldKey = `name-${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;
                                const defaultValue = field.value ?? '';
                                // Use _itemId in key to force remount when item is recreated after deletion
                                const itemKey = (currentItem as { _itemId?: string })?._itemId || `item-${itemIdx}`;

                                return (
                                  <>
                                    <Input
                                      key={`name-${itemKey}-${defaultValue}`}
                                      defaultValue={defaultValue}
                                      onChange={(e) => {
                                        // Only update ref, no state update = no re-render
                                        localInputValuesRef.current[fieldKey] = e.target.value;
                                      }}
                                      onBlur={(e) => {
                                        field.onBlur();
                                        field.onChange(e.target.value);
                                        // Clear from ref after sync
                                        delete localInputValuesRef.current[fieldKey];
                                      }}
                                      disabled={isItemFromAi}
                                      className={cn(
                                        itemErrors?.name && 'border-red-500',
                                        isItemFromAi && 'bg-gray-100 cursor-not-allowed'
                                      )}
                                    />
                                    <div className="min-h-[16px]">
                                      {itemErrors?.name && (
                                        <p className="text-xs text-red-600 mt-1">{itemErrors.name.message}</p>
                                      )}
                                    </div>
                                  </>
                                );
                              }}
                            />
                          </div>
                          {renderNumberInput('calories', 'meal_plan.items_dialog.cal_label', 'cal')}
                          {renderNumberInput('protein', 'meal_plan.items_dialog.protein_label', 'protein')}
                          {renderNumberInput('carbs', 'meal_plan.items_dialog.carbs_label', 'carbs')}
                          {renderNumberInput('fat', 'meal_plan.items_dialog.fat_label', 'fat')}
                          <div className="md:col-span-2 space-y-1">
                            <Label>{t('meal_plan.items_dialog.ingredients_label')}</Label>
                            <Controller
                              name={`days.${itemsModal.dayIdx}.meals.${itemsModal.mealIdx}.items.${itemIdx}.ingredients`}
                              control={control}
                              render={({ field }) => {
                                const fieldKey = `${itemsModal.dayIdx}-${itemsModal.mealIdx}-${itemIdx}`;

                                // Convert ingredients to display string (one per line)
                                const displayValueFromField = (field.value || [])
                                  .map((ing: unknown) => {
                                    if (typeof ing === 'string') {
                                      return ing;
                                    }
                                    if (ing && typeof ing === 'object' && 'name' in ing) {
                                      const ingObj = ing as { name: string; quantity_g?: number };
                                      return ingObj.quantity_g ? `${ingObj.name} (${ingObj.quantity_g}g)` : ingObj.name;
                                    }
                                    return '';
                                  })
                                  .filter(Boolean)
                                  .join('\n');
                                // Use _itemId in key to force remount when item is recreated after deletion
                                const itemKey = (currentItem as { _itemId?: string })?._itemId || `item-${itemIdx}`;

                                return (
                                  <div>
                                    <Textarea
                                      key={`ingredients-${itemKey}-${displayValueFromField}`}
                                      className={cn(
                                        'w-full resize-y',
                                        itemErrors?.ingredients && 'border-red-500',
                                        isItemFromAi && 'bg-gray-100 cursor-not-allowed'
                                      )}
                                      rows={
                                        displayValueFromField
                                          ? Math.max(1, displayValueFromField.split('\n').length)
                                          : 1
                                      }
                                      style={{
                                        minHeight: '38px',
                                        maxHeight: '200px'
                                      }}
                                      defaultValue={displayValueFromField}
                                      placeholder={
                                        t('meal_plan.items_dialog.ingredients_placeholder') ||
                                        'Mi dng mt nguyn liu'
                                      }
                                      disabled={isItemFromAi}
                                      onChange={(e) => {
                                        if (isItemFromAi) return; // Prevent editing when item is from AI
                                        localInputValuesRef.current[`ingredients-${fieldKey}`] = e.target.value;
                                      }}
                                      onBlur={(e) => {
                                        if (isItemFromAi) return; // Prevent editing when item is from AI
                                        field.onBlur();
                                        // Convert textarea lines back to array of strings when user leaves the field
                                        const newValue = e.target.value
                                          ? e.target.value
                                              .split('\n')
                                              .map((s) => s.trim())
                                              .filter(Boolean)
                                          : [];
                                        field.onChange(newValue);
                                        // Clear ref after processing
                                        delete localInputValuesRef.current[`ingredients-${fieldKey}`];
                                      }}
                                    />
                                    <div className="min-h-[16px]">
                                      {itemErrors?.ingredients && (
                                        <p className="text-xs text-red-600 mt-1">{itemErrors.ingredients.message}</p>
                                      )}
                                    </div>
                                  </div>
                                );
                              }}
                            />
                          </div>
                          <div className="flex items-start">
                            <Button
                              type="button"
                              variant="destructive"
                              size="sm"
                              className="shrink-0 mt-[22px]"
                              onClick={() => removeItem(itemsModal.dayIdx, itemsModal.mealIdx, itemIdx)}
                            >
                              {t('common.remove')}
                            </Button>
                          </div>
                        </div>
                      </div>
                    );
                  });
                })()}
              </div>
              {(() => {
                const mealErrors = errors.days?.[itemsModal.dayIdx]?.meals?.[itemsModal.mealIdx];
                const itemsError = mealErrors?.items;
                if (itemsError && typeof itemsError === 'object' && 'message' in itemsError) {
                  return (
                    <div className="min-h-[20px] flex-shrink-0">
                      <p className="text-sm text-red-600">{itemsError.message as string}</p>
                    </div>
                  );
                }
                return null;
              })()}
            </div>
          )}
        </DialogContent>
      </Dialog>

      <div className="flex justify-end gap-2 pt-2">
        <Button type="submit" className="bg-[#F05A29] hover:bg-[#E04A1F]" disabled={loading}>
          {loading ? t('common.saving') : t('common.save')}
        </Button>
      </div>
    </form>
  );
};
